from asyncio import Task
from typing import Any, Callable, Concatenate, Coroutine, Protocol, Self, overload

__all__ = [
    "methodlike",
    "streamify",
    "signalize",
    "astreamify",
    "asignalize",
    "to_coro",
    "to_task",
]

# ============================================================
# typing
# ============================================================

class MethodLike[T, **P, R](Protocol):
    @overload
    def __get__(
        self, instance: None, owner: type[T], /
    ) -> Callable[Concatenate[T, P], R]: ...
    @overload
    def __get__(
        self, instance: T, owner: type[T] | None = None, /
    ) -> Callable[P, R]: ...

class MethodDescriptor[T, **P, R](MethodLike[T, P, R]):
    wrapper: Callable[..., Callable[P, R]]
    wrapped: Callable[Concatenate[T, P], R]
    def __init_subclass__(cls, /, wrapper: Callable[..., Callable[P, R]]) -> None: ...
    def __init__(self, wrapped: Callable[Concatenate[T, P], R]) -> None: ...
    def __set_name__(self, owner: type[T], name: str) -> None: ...

def methodlike[T, **P, R](m: Callable[Concatenate[T, P], R]) -> MethodLike[T, P, R]: ...

# ============================================================
# synchronous
# ============================================================

class Stream[**P, R]:
    __wrapped__: Callable[P, R]
    def __init__(self, wrapped: Callable[P, R]) -> None: ...
    def __call__(self, *args: P.args, **kwargs: P.kwargs) -> R: ...
    def __iter__(self) -> Self: ...
    def __next__(self) -> R: ...
    def wait(self) -> R | None: ...
    def get(self) -> R | None: ...
    def close(self) -> None: ...

class Signal[**P, R]:
    __wrapped__: Callable[P, R]
    def __init__(self, wrapped: Callable[P, R]) -> None: ...
    def __call__(self, *args: P.args, **kwargs: P.kwargs) -> R: ...
    def get(self) -> bool: ...
    def wait(self) -> None: ...

class streamify[T, **P, R](MethodDescriptor[T, P, R], wrapper=Stream[P, R]):
    @overload
    def __get__(
        self, instance: None, owner: type[T]
    ) -> Callable[Concatenate[T, P], R]: ...
    @overload
    def __get__(self, instance: T, owner: type[T] | None = None) -> Stream[P, R]: ...

class signalize[T, **P, R](MethodDescriptor[T, P, R], wrapper=Signal[P, R]):
    @overload
    def __get__(
        self, instance: None, owner: type[T]
    ) -> Callable[Concatenate[T, P], R]: ...
    @overload
    def __get__(self, instance: T, owner: type[T] | None = None) -> Signal[P, R]: ...

# ============================================================
# asynchronous
# ============================================================

class AStream[**P, R]:
    __wrapped__: Callable[P, R]
    def __init__(self, wrapped: Callable[P, R]) -> None: ...
    def __call__(self, *args: P.args, **kwargs: P.kwargs) -> R: ...
    def __aiter__(self) -> Self: ...
    async def __anext__(self) -> R: ...
    async def wait(self) -> R | None: ...
    def get(self) -> R | None: ...
    def close(self) -> None: ...

class ASignal[**P, R]:
    __wrapped__: Callable[P, R]
    def __init__(self, wrapped: Callable[P, R]) -> None: ...
    def __call__(self, *args: P.args, **kwargs: P.kwargs) -> R: ...
    def get(self) -> bool: ...
    async def wait(self) -> None: ...

class astreamify[T, **P, R](MethodDescriptor[T, P, R], wrapper=AStream[P, R]):
    @overload
    def __get__(
        self, instance: None, owner: type[T]
    ) -> Callable[Concatenate[T, P], R]: ...
    @overload
    def __get__(self, instance: T, owner: type[T] | None = None) -> AStream[P, R]: ...

class asignalize[T, **P, R](MethodDescriptor[T, P, R], wrapper=ASignal[P, R]):
    @overload
    def __get__(
        self, instance: None, owner: type[T]
    ) -> Callable[Concatenate[T, P], R]: ...
    @overload
    def __get__(self, instance: T, owner: type[T] | None = None) -> ASignal[P, R]: ...

def to_coro[**P, R](
    wrapped: Callable[P, R],
) -> Callable[P, Coroutine[Any, Any, R]]: ...
def to_task[**P, R](
    wrapped: Callable[P, Coroutine[Any, Any, R]],
) -> Callable[P, Task[R]]: ...
